;@com.wudsn.ide.asm.hardware=APPLE2 
; Chiptune Player for MOCKINGBOARD (based on FYM format)
; FYM player
; by fenarinarsa (2019/2020) and Grouik/FRENCH TOUCH (2017)
;
; This file is part of FYM.
;
; FYM is free software: you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; (at your option) any later version.
;
; FYM is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with FYM.  If not, see<https://www.gnu.org/licenses/>.


!convtab "a2txt.bin" 	; incorporation table caractère APPLE II (normal) générale
!sl "lbl_main.txt"		; sauvegarde labels (debug)
!cpu 6502

	*= $1000 		; ORG

; SETUP

STEREO = 1	; set to 1 to use both AYs (slower)


; CONSTANTES

; Page ZERO

Temp	= $EB

bvolA	= $F9
bvolB	= $FA
bvolC	= $FC

SeqCount	= $F6
SeqLength	= $FB

OUT1	= $20 	; +$21
OUT2	= $22 	; +$23
OUT3	= $24	; +$25
OUT4	= $26 	; +$27
pattern	= $28

TimeAL = $2a
TimeAH = $2b
TimeBL = $2c
TimeBH = $2d
CPUlowL = $2e
CPUlowH = $2f
CPUhighL = $30
CPUhighH = $31

TableOffsetDataL = $40  ; ~5B
;TableOffsetDataH = $41  ; ~4E
TableIndex = $60
TableCompteur = $70


pPartition = $F7 ; +$F8	

Mem	= $FD ; +$FE
IndexRegister	= $FF

_RAMRDmain = $C002
_RAMRDaux	= $C003
_RAMWRTmain = $C004
_RAMWRTaux = $C005

AUXMOVE = $C311
A2L = $3E ; source for auxmove
A4L = $42 ; destination for auxmove

!macro set_ptr .src, .pointer {
	lda #<.src
	sta .pointer
	lda #>.src
	sta .pointer+1
}

; =============================================================================

MAIN	
!zone
	+set_ptr $1000,A2L
	+set_ptr $1000+15000,A4L
	sec
	jsr AUXMOVE
	; switches to 48k AUX
	sta _RAMRDmain
	sta _RAMWRTmain
	

	BIT $C051
	BIT $C054
	STA $C010  				; strob KB
	
	LDA #01
	STA bvolA
	STA bvolB
	STA bvolC
	
	; MB4c activation on IIc
	LDA #$FF
	STA $C404
	STA $C405
	

	JSR DETECTMB
	
.Ok	; good guy
	
	sta 0xC00F ; enable MOUSETEXT

	; clear TEXT1
	ldx #$ff
	lda	#" "
.fill	sta $400,x
	sta $500,x
	sta $600,x
	sta $700,x
	dex
	bne .fill		
	; fill TEXT2 for debug
	ldx #$ff
	ldy #" "
	lda	#$20
.fill1	sta $800,x
	sta $900,x
	sta $a00,x
	sta $b00,x
	dex
	bne .fill1

init_debug
	LDA #0
	STA CPUhighH
	LDA #70
	STA CPUlowH	
	
	LDX #$27
.bt	LDA Tregisters,X
	STA $480,X
	LDA Title,X
	STA $500,X
	LDA Tpointers,X
	STA $680,X
	LDA Tpartition,X
	STA $4A8,X
	LDA Tcpu,X
	STA $628,X
	LDA THaut,X
	STA $400,X
	LDA TBas,X
	STA $7D0,X
	DEX
	BPL .bt
	
	CLC
	LDA OUT2+1
	AND #$0F
	ADC #"0"
	STA $403
	
	; -----------------------------------------------------------
	; interrupt setup
	SEI					; inhib
	lda	$c08b ; disable ROM
	lda	$c08b
	; vecteur
	LDA #<PLAYERYM
	STA $FFFE
	LDA #>PLAYERYM
	STA $FFFF
	; interruption - TIMER 1 6522 
	LDA #%01000000		; continuous interrupt / PB7 disabled
	STA $C40B			; Auxiliary Control Register

	LDA #%11000000		; 
	STA $C40D			; interrupt flag register	(Time Out of Timer 1/Int)
	STA $C40E			; interrupt Enable register (Timer 1 + Set)
	
	; 50 Hz = 20 ms = 20 000 microsecond = 20 000 tick environ (1 Mhz d'holorge) = $4E20
	; On PAL //c timing are differents, 4F36 is the right number to get the exact same point each VBL
	; the main clock seems to be 14238000Hz/4 = 1017000Hz
	; 1017000/$4F36 = 50,15fps, and OSSC indicates a rounded fps value of 50.20Hz so it everything looks like it's the right number
	; PAL = 1.015657 (20280 cycles / frame) (192*65 + (50*65 + 70*65))
	; NTSC = 1.020484 (17030 cycles / frame) 192*65 + (70*65)
	LDA #$36
	STA $C404			; T1C-Lower
	LDA #$4F
	STA $C405			; T1C-High
	; -----------------------------------------------------------
	
	; init MB (OUT1)
	LDA #$FF
	STA $C403		; DDRA1
	STA $C483		; DDRA2
	LDA #$07
	STA $C402		; DDRB1
	STA $C482		; DDRB2

	; RESET (clean all registers)
	LDA #$00	; Set fct "Reset"
	STA $C400
	LDA #$04	; Set fct "Inactive"
	STA $C400
	
	LDA #$00	; Set fct "Reset"
	STA $C480	
	LDA #$04	; Set fct "Inactive"
	STA $C480
	
	JSR YMRESET
	
	LDA #0
	STA pattern

	; prepare tune data

	LDA $2000
	STA SeqLength
	STA SeqCount

relocate_partition
	; relocate partition pointers
	LDA #$20
	STA pPartition+1
	STA Mem+1
	LDA #$01
	STA pPartition
	STA Mem
.reloc1	LDY #1
	CLC
.reloc0	LDA (Mem),Y
	ADC #$20
	STA (Mem),Y
	INY
	INY
	CPY #29
	BNE .reloc0
	LDY #29
	LDA (Mem),Y
	BEQ .end_relocate ; partition end
	CLC
	LDA Mem
	ADC #28
	STA Mem
	BCC .reloc1
	LDA Mem+1
	ADC #0
	STA Mem+1
	JMP .reloc1
.end_relocate

	JSR init_packbits


		
start	CLI	; interrupt ON !
		
	; main loop
.BP
	JSR debug

	; ---------------------
	; check keyboard

	LDA $C000
	BPL .BP
	
	AND #%11011111	; MIN->MAJ
	STA $C010
	
	CMP #$C1		; A
	BNE .sk2
	LDA $412
	CMP #'A'
	BNE .s1
	LDA #' '
	STA $412
	JMP .s2
.s1		LDA #'A'
	STA $412		
.s2		LDA bvolA
	EOR #01
	STA bvolA
	JMP .BP
		
.sk2	CMP #$C2		; B
	BNE .sk3
	LDA $413
	CMP #'B'
	BNE .s3
	LDA #' '
	STA $413
	JMP .s4
.s3		LDA #'B'
	STA $413		
.s4		LDA bvolB
	EOR #01
	STA bvolB
	JMP .BP
		
.sk3	CMP #$C3		; C
	BNE .BP
	LDA $414
	CMP #'C'
	BNE .s5
	LDA #' '
	STA $414
	JMP .s6
.s5		LDA #'C'
	STA $414		
.s6		LDA bvolC
	EOR #01
	STA bvolC

	JMP .BP	

	; RESET (no more sound)
	LDA #$00	; Set fct "Reset"
	STA $C400
	STA $C480	
	LDA #$04	; Set fct "Inactive"
	STA $C400
	STA $C480
	
	RTS
		
; =============================================================================
; DISPLAY DEBUG INFO

debug	lda #$00
	tay
	tax
	lda #$05
	sta $01
	lda #$81
	sta $00
		
	; display YM registers
.dbg_reg
	lda TableData,X
	jsr PRBYTE
	inx
	cpx #14
	bne .dbg_reg

	; display ptr high
	lda #$07
	sta $01
	lda #$01
	sta $00
	ldx #$00
	ldy #$00
.dbg_ptrH
	lda TableOffsetDataL+1,X
	jsr PRBYTE
	INX
	INX
	cpx #28
	bne .dbg_ptrH

	; display ptr low
	lda #$81
	sta $00
	ldx #$00
	ldy #$00
	LDA #TableIndex
	STA .dbg8_mod+1
.dbg_ptrB
	CLC
	lda TableOffsetDataL,X
.dbg8_mod	ADC TableIndex
	jsr PRBYTE
	inx
	INX
	INC .dbg8_mod+1
	cpx #28
	bne .dbg_ptrB
	
	; display RLE control bytes
;	lda #$04
;	sta $01
;	ldx #$00
;	ldy #$00
;.dbg_ptrC
;	lda TableCompteur,X
;	jsr PRBYTE
;	inx
;	cpx #14
;	bne .dbg_ptrC
	
	; display partition pointer
	lda #$29
	sta $00
	lda #$05
	sta $01
	ldy #$00
	ldx #$01
	lda pPartition,X
	jsr PRBYTE
	dex
	lda pPartition,X
	jsr PRBYTE
	iny
	lda SeqCount
	jsr PRBYTE
	iny
	lda pattern
	jsr PRBYTE
		
	rts
		
; =============================================================================
PLAYERYM
!zone
	php
	pha			; on sauve A
	TXA
	PHA
	TYA
	PHA
	STA $C055		; uncomment to show player execution time on screen (may be not visible each time you run it)
	; "remplissage" Registres
	BIT $C404           ; Clears interrupt (T1CL)

	; gets counter to display CPU time
	LDX $C404  ; 4
	LDY $C405  ; 4
	STX TimeAL ; 3
	STY TimeAH ; 3


	!zone psg
	LDX #00
	; R0/R1/R2/R3/R4/R5/R6/R7
.br1	LDA TableData,X
	;AY-1
	STX $C401			; ORA1 (data)
	LDY #$07			; Set fct "Set PSG Reg #"
	STY $C400			; ORB1 (fct)
	LDY #$04			; Set fct "Inactive"
	STY $C400			; ORB1 (fct)
	STA $C401			; ORA1 (data)
	LDY #$06			; Set fct "Write DATA"
	STY $C400			; ORB1 (fct)
	LDY #$04			; Set fct "Inactive"
	STY $C400			; ORB1 (fct)
!if STEREO=1 {
	;AY-2
	STX $C481			; ORA1 (data)
	LDY #$07			; Set fct "Set PSG Reg #"
	STY $C480			; ORB1 (fct)
	LDY #$04			; Set fct "Inactive"
	STY $C480			; ORB1 (fct)
	STA $C481			; ORA1 (data)
	LDY #$06			; Set fct "Write DATA"
	STY $C480			; ORB1 (fct)
	LDY #$04			; Set fct "Inactive"
	STY $C480			; ORB1 (fct)
	}
	INX
	CPX #8				; 
	BNE .br1
	
	; -----------------------------
	; VOLUME A			; r8
	lda bvolA
	BNE .gA1
	LDA #00
	JMP .gA2
		
.gA1	LDA TableData,X		; value to put into aY register
.gA2	;AY-1
	STX $C401			; ORA1 (data)
	LDY #$07			; Set fct "Set PSG Reg #"
	STY $C400			; ORB1 (fct)
	LDY #$04			; Set fct "Inactive"
	STY $C400			; ORB1 (fct)
	STA $C401			; ORA1 (data)
	LDY #$06			; Set fct "Write DATA"
	STY $C400			; ORB1 (fct)
	LDY #$04			; Set fct "Inactive"
	STY $C400			; ORB1 (fct)
!if STEREO=1 {
	;AY-2
	STX $C481			; ORA1 (data)
	LDY #$07			; Set fct "Set PSG Reg #"
	STY $C480			; ORB1 (fct)
	LDY #$04			; Set fct "Inactive"
	STY $C480			; ORB1 (fct)
	STA $C481			; ORA1 (data)
	LDY #$06			; Set fct "Write DATA"
	STY $C480			; ORB1 (fct)
	LDY #$04			; Set fct "Inactive"
	STY $C480			; ORB1 (fct)
}
	
	; -----------------------------
	; VOLUME B
	INX			; r9
	lda bvolB
	BNE .gB1
	LDA #00
	JMP .gB2

.gB1	LDA TableData,X		; value to put into aY register
.gB2	;AY-1
	STX $C401			; ORA1 (data)
	LDY #$07			; Set fct "Set PSG Reg #"
	STY $C400			; ORB1 (fct)
	LDY #$04			; Set fct "Inactive"
	STY $C400			; ORB1 (fct)
	STA $C401			; ORA1 (data)
	LDY #$06			; Set fct "Write DATA"
	STY $C400			; ORB1 (fct)
	LDY #$04			; Set fct "Inactive"
	STY $C400			; ORB1 (fct)
!if STEREO=1 {
	;AY-2
	STX $C481			; ORA1 (data)
	LDY #$07			; Set fct "Set PSG Reg #"
	STY $C480			; ORB1 (fct)
	LDY #$04			; Set fct "Inactive"
	STY $C480			; ORB1 (fct)
	STA $C481			; ORA1 (data)
	LDY #$06			; Set fct "Write DATA"
	STY $C480			; ORB1 (fct)
	LDY #$04			; Set fct "Inactive"
	STY $C480			; ORB1 (fct)
}
	
	; -----------------------------
	; VOLUME C
	INX			; r10
	lda bvolC
	BNE .gC1
	LDA #00
	JMP .gC2
		
.gC1	LDA TableData,X		; value to put into aY register
.gC2	;AY-1
	STX $C401			; ORA1 (data)
	LDY #$07			; Set fct "Set PSG Reg #"
	STY $C400			; ORB1 (fct)
	LDY #$04			; Set fct "Inactive"
	STY $C400			; ORB1 (fct)
	STA $C401			; ORA1 (data)
	LDY #$06			; Set fct "Write DATA"
	STY $C400			; ORB1 (fct)
	LDY #$04			; Set fct "Inactive"
	STY $C400			; ORB1 (fct)
!if STEREO=1 {
	;AY-2
	STX $C481			; ORA1 (data)
	LDY #$07			; Set fct "Set PSG Reg #"
	STY $C480			; ORB1 (fct)
	LDY #$04			; Set fct "Inactive"
	STY $C480			; ORB1 (fct)
	STA $C481			; ORA1 (data)
	LDY #$06			; Set fct "Write DATA"
	STY $C480			; ORB1 (fct)
	LDY #$04			; Set fct "Inactive"
	STY $C480			; ORB1 (fct)
}
	; -----------------------------

	INX			; r11
	; R11/R12/R13
.br2	LDA TableData,X
	;AY-1
	STX $C401			; ORA1 (data)
	LDY #$07			; Set fct "Set PSG Reg #"
	STY $C400			; ORB1 (fct)
	LDY #$04			; Set fct "Inactive"
	STY $C400			; ORB1 (fct)
	STA $C401			; ORA1 (data)
	LDY #$06			; Set fct "Write DATA"
	STY $C400			; ORB1 (fct)
	LDY #$04			; Set fct "Inactive"
	STY $C400			; ORB1 (fct)
!if STEREO=1 {
	;AY-2
	STX $C481			; ORA1 (data)
	LDY #$07			; Set fct "Set PSG Reg #"
	STY $C480			; ORB1 (fct)
	LDY #$04			; Set fct "Inactive"
	STY $C480			; ORB1 (fct)
	STA $C481			; ORA1 (data)
	LDY #$06			; Set fct "Write DATA"
	STY $C480			; ORB1 (fct)
	LDY #$04			; Set fct "Inactive"
	STY $C480			; ORB1 (fct)
}
	INX
	CPX #13
	BNE .br2
	
	LDA TableData,X
	CMP #$FF
	BEQ .no_r13update1
	;AY-1
	STX $C401			; ORA1 (data)
	LDY #$07			; Set fct "Set PSG Reg #"
	STY $C400			; ORB1 (fct)
	LDY #$04			; Set fct "Inactive"
	STY $C400			; ORB1 (fct)
	STA $C401			; ORA1 (data)
	LDY #$06			; Set fct "Write DATA"
	STY $C400			; ORB1 (fct)
	LDY #$04			; Set fct "Inactive"
	STY $C400			; ORB1 (fct)
!if STEREO=1 {
	;AY-2
	STX $C481			; ORA1 (data)
	LDY #$07			; Set fct "Set PSG Reg #"
	STY $C480			; ORB1 (fct)
	LDY #$04			; Set fct "Inactive"
	STY $C480			; ORB1 (fct)
	STA $C481			; ORA1 (data)
	LDY #$06			; Set fct "Write DATA"
	STY $C480			; ORB1 (fct)
	LDY #$04			; Set fct "Inactive"
	STY $C480			; ORB1 (fct)
}
		
.no_r13update1


	!zone unpack_data
	DEC SeqCount
	BNE unpack_pattern
	JMP next_sequence
	
unpack_pattern
	; handling packbits
	
	LDX #13		; 14 registers
!for i,0,13 {
	!zone
	LDY TableCompteur+i
	BEQ .controlbyte ; ==0 read next control byte
	BMI .dupmode

.copymode ; counter is positive
	DEY
	STY TableCompteur+i

	LDY TableIndex+i
	LDA (TableOffsetDataL+(i*2)),Y
	STA TableData+i
	INY
	STY TableIndex+i
	
!if i<13 {
	JMP .nextreg
} else {
	JMP exit_interrupt
}

.dupmode	; counter is negative
	INY
	STY TableCompteur+i
!if i<13 {
	JMP .nextreg
} else {
	JMP exit_interrupt
}

.controlbyte
	LDY TableIndex+i
	LDA (TableOffsetDataL+(i*2)),Y	; control byte
	STA TableCompteur+i
	INY
	LDA (TableOffsetDataL+(i*2)),Y	; value byte
	STA TableData+i
	INY
	STY TableIndex+i
!if i<13 {
	JMP .nextreg
} else {
	JMP exit_interrupt
}

.nextreg
}

next_sequence
	; we are at the end of the pattern sequence
	; reset sequence count
	LDA SeqLength
	STA SeqCount

	; next partition sequence (+28 bytes)
	CLC
	LDA pPartition
	ADC #28
	STA pPartition
	LDA pPartition+1
	ADC #0
	STA pPartition+1

	INC pattern	; debug
	
	LDY #1
	LDA (pPartition),Y
	BNE .no_loop
	; end of partition, looping to the start of the song
	LDY #0
	STY pattern
	LDA #$20
	STA pPartition+1
	LDA #$01
	STA pPartition
		
.no_loop
	; reset packbits depack counters for all 14 registers
	JSR init_packbits

exit_interrupt
	; gets counter to display CPU time
	LDX $C404
	LDY $C405
          STX TimeBL
          STY TimeBH

display_cpu_time
	; adjust recorded values
	LDX TimeAL
	DEX
	DEX
	DEX
	DEX
	STX TimeAL
	LDX TimeBL
	DEX
	DEX
	DEX
	DEX
	STX TimeBL
	; substract TIMEA-TIMEB => compte à rebour!
	SEC
	LDA TimeAL           ; low
	SBC TimeBL
	STA TimeAL
	LDA TimeAH           ; high
	SBC TimeBH
	STA TimeAH

	LDX TimeAH
	LDY TimeAL
	CPX CPUlowH
	BCC .faster	; H < H fast
	BNE .testslow	; H > H fast ==> slower?
	; H == H fast
	CPY CPUlowL
	BCS .testslow	; L >= L fast ==> slower?
.faster	STX CPUlowH
	STY CPUlowL
	JMP .display

.testslow	CPX CPUhighH
	BCC .display	; H < H slow ==> end
	BNE .slower	; H > H slow ==> slower
	; H == H slow
	CPY CPUhighL
	BCC .display	; L < L slow ==> end
.slower	STX CPUhighH
	STY CPUhighL

.display
	; save PRBYTE params
	LDA $00
	PHA
	LDA $01
	PHA
	; display timer
	LDA #$A8
	STA $00
	LDA #$06
	STA $01
	LDY #$00
	LDA TimeAH
	JSR PRBYTE
	LDA TimeAL
	JSR PRBYTE
	INY
	LDA CPUlowH
	JSR PRBYTE
	LDA CPUlowL
	JSR PRBYTE
	INY
	LDA CPUhighH
	JSR PRBYTE
	LDA CPUhighL
	JSR PRBYTE
	; restore PRBYTE params
	PLA
	STA $01
	PLA
	STA $00
	
	STA $c054
	
	PLA
	TAY
	PLA
	TAX
	PLA
	PLP
	RTI	; sortie 2

init_packbits
	!zone
	; packbits file format
	; 1 control byte (n) + ? data bytes
	; if control byte ==128 => end
	; if control byte <128 => copy n+1 data bytes
	; if control byte >128 => repeat 1 data byte 257-n times

	; copy partition pointers
	LDY #0
!for i,0,27 {
	LDA (pPartition),Y
	STA TableOffsetDataL+i
	INY
}

	; init 13 patterns' packbits
	LDY #0
	LDX #2
!for i,0,13 {
	LDA (TableOffsetDataL+(i*2)),Y	; control byte
	STA TableCompteur+i
	INY
	LDA (TableOffsetDataL+(i*2)),Y	; value byte
!if i<13 {
	DEY
}
	STA TableData+i
	STX TableIndex+i
}
	RTS



; -----------------------------------------------------------------------------
DETECTMB
!zone
	; MB / SLOT #?
	LDA #00
	STA OUT2
.bdet	LDA #$07		; on commence en $C7 jusqu'en $C1
	ORA #$C0		; -> $Cx
	STA OUT2+1
	LDY #04		; $CX04
	LDX #02		; 2 vérifs

.bt	LDA (OUT2),Y	; timer 6522 (Low Order Counter) - attention compte � rebour !
	STA Temp		; 3 cycles
	LDA (OUT2),Y	; + 5 cycles = 8 cycles entre les deux accès au timer
	SEC						; 
	SBC Temp		; 
	CMP #$F8		; -8 (compte à rebour) ?
	BNE .Ko
	DEX
	BNE .bt		; boucle détection
	INX		; Mocking OK (X=1)
.end	LDA .bdet+1
	CLC
	ADC #"0"
	STA $403
	;STX bMB					;
	RTS
		
.Ko	DEC .bdet+1	; on décrémente le "slot"
	BNE .bdet		; on boucle de 7 à 1
	;INC bGood	; !=0 bad guy si pas de MB  *** Eventuellement � comment si suite OK sans MB ***
	LDX #00
	;BEQ .end		; tj pris - on sort (bad guy)
	RTS
			
; =============================================================================
Init_MB			; init Mockingboard		 		
!zone	

	LDA		#$80
	STA OUT4
	LDA OUT2+1
	STA OUT1+1
	STA OUT3+1
	STA OUT4+1
	;STA		OFFBIT+2	; fixe BIT $Cx04 (réinit interruption) du player
	LDA #$01
	STA OUT1
	LDA #$81
	STA OUT3		

	; PREMIER init MB (OUT2/OUT4)
	LDA #$FF
	LDY #$03
	STA (OUT2),Y	; STA   $C403		; DDRA1
	STA (OUT4),Y	; STA   $C483		; DDRA2
	LDA #$07
	LDY #$02
	STA (OUT2),Y	; STA   $C402		; DDRB1
	STA (OUT4),Y	; STA   $C482		; DDRB2
	RTS
			
; =============================================================================
YMRESET
!zone
	LDX #0
	
.bp	LDA YMResetData,X

	;AY-1
	STX $C401		; ORA1 (data)
	LDY #$07		; Set fct "Set PSG Reg #"
	STY $C400		; ORB1 (fct)
	LDY #$04		; Set fct "Inactive"
	STY $C400		; ORB1 (fct)
	STA $C401		; ORA1 (data)
	LDY #$06		; Set fct "Write DATA"
	STY $C400		; ORB1 (fct)
	LDY #$04		; Set fct "Inactive"
	STY $C400		; ORB1 (fct)
	
	;AY-2
	STX $C481
	LDY #$07		; Set fct "Set PSG Reg #"
	STY $C480
	LDY #$04		; Set fct "Inactive"
	STY $C480
	STA $C481
	LDY #$06		; Set fct "Write DATA"
	STY $C480
	LDY #$04		; Set fct "Inactive"
	STY $C480

	lda #0
	sta TableData,X
	
	INX
	CPX #14
	BNE .bp

	RTS

YMResetData	!byte 0,0,0,0,0,0,0,$3F,0,0,0,0,0,0
		
			
; =============================================================================
!align 255,0


TableData 		!fill 14,00


;................0000000000111111111122222222223333333333
;................0123456789012345678901234567890123456789 		
Title 	!text	" 00112233445566778899AABBCCDD           "	
;................0000000000000000111111111111111122222222
;................0123456789ABCDEF0123456789ABCDEF01234567
THaut 	!text	"MB=               ABC     FENARINARSA/FT"
;................0000000000111111111122222222223333333333
;................0123456789012345678901234567890123456789
TBas !text	 	"PLAYER v0.04 FYM                   2x3CH"
Tregisters		!byte $4A
		!text	"registers                              "
Tpointers		!byte $4A
		!text	"patterns ptr                           "
Tpartition  	!byte $4A
		!text	"partition ptr                          "
Tcpu  	!byte $4A
		!text	"cpu min  max                           "



!src "tools.a"